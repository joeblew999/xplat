package manifest

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

// Generator generates files from manifests.
type Generator struct {
	manifests []*Manifest
}

// NewGenerator creates a new generator with the given manifests.
func NewGenerator(manifests []*Manifest) *Generator {
	return &Generator{manifests: manifests}
}

// GenerateEnvExample generates a .env.example file.
func (g *Generator) GenerateEnvExample(outputPath string) error {
	var buf bytes.Buffer

	buf.WriteString("# Generated by: xplat docs env\n")
	buf.WriteString("# Regenerate with: xplat docs env\n")
	buf.WriteString("#\n")
	buf.WriteString("# This file documents all environment variables needed by xplat packages.\n")
	buf.WriteString("# Copy to .env and fill in your values.\n\n")

	for _, m := range g.manifests {
		if !m.HasEnv() {
			continue
		}

		buf.WriteString(fmt.Sprintf("# === %s ===\n", m.Name))
		if m.Description != "" {
			buf.WriteString(fmt.Sprintf("# %s\n", m.Description))
		}
		buf.WriteString("\n")

		// Required vars
		for _, v := range m.Env.Required {
			writeEnvVar(&buf, v, true)
		}

		// Optional vars
		for _, v := range m.Env.Optional {
			writeEnvVar(&buf, v, false)
		}

		buf.WriteString("\n")
	}

	return os.WriteFile(outputPath, buf.Bytes(), 0644)
}

func writeEnvVar(buf *bytes.Buffer, v EnvVar, required bool) {
	if v.Description != "" {
		buf.WriteString(fmt.Sprintf("# %s", v.Description))
		if required {
			buf.WriteString(" (required)")
		}
		buf.WriteString("\n")
	}

	if v.Instructions != "" {
		for _, line := range strings.Split(strings.TrimSpace(v.Instructions), "\n") {
			buf.WriteString(fmt.Sprintf("#   %s\n", line))
		}
	}

	if v.Default != "" {
		buf.WriteString(fmt.Sprintf("# %s=%s\n", v.Name, v.Default))
	} else {
		buf.WriteString(fmt.Sprintf("%s=\n", v.Name))
	}
	buf.WriteString("\n")
}

// ProcessComposeConfig represents a process-compose.yaml file.
type ProcessComposeConfig struct {
	Version   string                            `yaml:"version"`
	Processes map[string]ProcessComposeProcess `yaml:"processes"`
}

// ProcessComposeProcess represents a single process in process-compose.
type ProcessComposeProcess struct {
	Command        string                     `yaml:"command"`
	Disabled       bool                       `yaml:"disabled,omitempty"`
	DependsOn      map[string]DependsOnConfig `yaml:"depends_on,omitempty"`
	ReadinessProbe *ProbeConfig               `yaml:"readiness_probe,omitempty"`
	LivenessProbe  *ProbeConfig               `yaml:"liveness_probe,omitempty"`
	Availability   *AvailabilityConfig        `yaml:"availability,omitempty"`
}

type DependsOnConfig struct {
	Condition string `yaml:"condition"`
}

type ProbeConfig struct {
	HTTPGet             *HTTPGetConfig `yaml:"http_get,omitempty"`
	Exec                *ExecConfig    `yaml:"exec,omitempty"`
	InitialDelaySeconds int            `yaml:"initial_delay_seconds,omitempty"`
	PeriodSeconds       int            `yaml:"period_seconds,omitempty"`
	TimeoutSeconds      int            `yaml:"timeout_seconds,omitempty"`
	FailureThreshold    int            `yaml:"failure_threshold,omitempty"`
}

type HTTPGetConfig struct {
	Path   string `yaml:"path"`
	Port   int    `yaml:"port"`
	Scheme string `yaml:"scheme,omitempty"`
}

type ExecConfig struct {
	Command string `yaml:"command"`
}

type AvailabilityConfig struct {
	Restart string `yaml:"restart"`
}

// GenerateProcessCompose generates a process-compose.yaml file.
func (g *Generator) GenerateProcessCompose(outputPath string) error {
	config := ProcessComposeConfig{
		Version:   "0.5",
		Processes: make(map[string]ProcessComposeProcess),
	}

	for _, m := range g.manifests {
		if !m.HasProcesses() {
			continue
		}

		for name, p := range m.Processes {
			// Prefix process name with package name to avoid conflicts
			processName := name
			if len(g.manifests) > 1 {
				processName = fmt.Sprintf("%s-%s", m.Name, name)
			}

			proc := ProcessComposeProcess{
				Command:  p.Command,
				Disabled: p.Disabled,
				Availability: &AvailabilityConfig{
					Restart: "on_failure",
				},
			}

			// Add depends_on
			if len(p.DependsOn) > 0 {
				proc.DependsOn = make(map[string]DependsOnConfig)
				for _, dep := range p.DependsOn {
					proc.DependsOn[dep] = DependsOnConfig{Condition: "process_healthy"}
				}
			}

			// Add readiness probe
			if p.Port > 0 && p.HealthPath != "" {
				scheme := "http"
				if p.HTTPS {
					scheme = "https"
				}
				proc.ReadinessProbe = &ProbeConfig{
					HTTPGet: &HTTPGetConfig{
						Path:   p.HealthPath,
						Port:   p.Port,
						Scheme: scheme,
					},
				}
				if p.Readiness != nil {
					proc.ReadinessProbe.InitialDelaySeconds = p.Readiness.InitialDelay
					proc.ReadinessProbe.PeriodSeconds = p.Readiness.Period
					proc.ReadinessProbe.TimeoutSeconds = p.Readiness.Timeout
					proc.ReadinessProbe.FailureThreshold = p.Readiness.FailureThreshold
				}
			}

			config.Processes[processName] = proc
		}
	}

	// Marshal to YAML
	data, err := yaml.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal process-compose config: %w", err)
	}

	// Add header comment
	header := "# Generated by: xplat docs process\n# Regenerate with: xplat docs process\n\n"
	output := append([]byte(header), data...)

	return os.WriteFile(outputPath, output, 0644)
}

// GenerateTaskfile generates a Taskfile with remote includes.
func (g *Generator) GenerateTaskfile(outputPath string, repoBaseURL string) error {
	const taskfileTmpl = `# Generated by: xplat docs taskfile
# Regenerate with: xplat docs taskfile

version: "3"

includes:
{{- range .Includes }}
  {{ .Namespace }}:
    taskfile: {{ .URL }}
{{- end }}

tasks:
  default:
    desc: List available tasks
    cmds:
      - task --list
`

	type include struct {
		Namespace string
		URL       string
	}

	var includes []include
	for _, m := range g.manifests {
		if m.Taskfile == nil || m.Taskfile.Path == "" {
			continue
		}

		ns := m.Taskfile.Namespace
		if ns == "" {
			ns = m.Name
		}

		// Build URL: https://github.com/owner/repo.git//path?ref=version
		url := fmt.Sprintf("%s/%s.git//%s?ref=%s",
			repoBaseURL, m.RepoName(), m.Taskfile.Path, m.Version)

		includes = append(includes, include{Namespace: ns, URL: url})
	}

	// Sort for consistent output
	sort.Slice(includes, func(i, j int) bool {
		return includes[i].Namespace < includes[j].Namespace
	})

	tmpl, err := template.New("taskfile").Parse(taskfileTmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]interface{}{"Includes": includes}); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return os.WriteFile(outputPath, buf.Bytes(), 0644)
}

// GenerateWorkflow generates a unified GitHub Actions CI workflow.
// This creates a minimal workflow that delegates to Taskfile.
// Downloads xplat binary for cross-platform shell operations.
// Runs on Linux, macOS, and Windows.
func (g *Generator) GenerateWorkflow(outputPath string) error {
	const workflowTmpl = `# Unified CI/CD workflow for plat-* repositories
#
# Generated by: xplat manifest gen-workflow
# Regenerate with: xplat manifest gen-workflow
#
# Uses xplat for cross-platform shell operations.
# Downloads xplat binary first, then uses it for all operations.
# Runs on Linux, macOS, and Windows.

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  XPLAT_VERSION: "v0.1.0"

jobs:
  ci:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            name: Linux
            xplat_binary: xplat-linux-amd64
          - os: macos-latest
            name: macOS
            xplat_binary: xplat-darwin-arm64
          - os: windows-latest
            name: Windows
            xplat_binary: xplat-windows-amd64.exe
    runs-on: ${{ matrix.os }}
    name: CI (${{ matrix.name }})
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-go@v5
        with:
          go-version: "stable"

      - name: Install xplat (Unix)
        if: runner.os != 'Windows'
        run: |
          curl -sL "https://github.com/joeblew999/xplat/releases/download/xplat-${{ env.XPLAT_VERSION }}/${{ matrix.xplat_binary }}" -o /usr/local/bin/xplat
          chmod +x /usr/local/bin/xplat
          xplat version

      - name: Install xplat (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\bin" | Out-Null
          Invoke-WebRequest -Uri "https://github.com/joeblew999/xplat/releases/download/xplat-${{ env.XPLAT_VERSION }}/${{ matrix.xplat_binary }}" -OutFile "$env:USERPROFILE\bin\xplat.exe"
          echo "$env:USERPROFILE\bin" | Out-File -FilePath $env:GITHUB_PATH -Append
          & "$env:USERPROFILE\bin\xplat.exe" version

      # All CI logic is in Taskfile - xplat task runs embedded Task
      # Same commands work locally: xplat task build
      - name: Build
        run: xplat task build

      - name: Test
        run: xplat task test

      - name: Lint
        run: xplat task lint
        continue-on-error: true
`

	return os.WriteFile(outputPath, []byte(workflowTmpl), 0644)
}

// GenerateWorkflowDir generates the workflow in .github/workflows/ci.yml
func (g *Generator) GenerateWorkflowDir(baseDir string) error {
	workflowDir := baseDir + "/.github/workflows"
	if err := os.MkdirAll(workflowDir, 0755); err != nil {
		return fmt.Errorf("failed to create workflow directory: %w", err)
	}
	return g.GenerateWorkflow(workflowDir + "/ci.yml")
}

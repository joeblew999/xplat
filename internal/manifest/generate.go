package manifest

import (
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/joeblew999/xplat/internal/processcompose"
	"github.com/joeblew999/xplat/internal/templates"
)

// portEnvVar derives the environment variable name for a process port.
// e.g., "web" -> "WEB_PORT", "api-server" -> "API_SERVER_PORT"
func portEnvVar(processName string) string {
	name := strings.ToUpper(processName)
	name = strings.ReplaceAll(name, "-", "_")
	return name + "_PORT"
}


// Generator generates files from manifests.
type Generator struct {
	manifests []*Manifest
}

// NewGenerator creates a new generator with the given manifests.
func NewGenerator(manifests []*Manifest) *Generator {
	return &Generator{manifests: manifests}
}

// GenerateEnvExample generates a .env.example file.
func (g *Generator) GenerateEnvExample(outputPath string) error {
	// Convert manifests to template data
	var envManifests []templates.EnvManifest
	for _, m := range g.manifests {
		if !m.HasEnv() {
			continue
		}

		em := templates.EnvManifest{
			Name:        m.Name,
			Description: m.Description,
			HasEnv:      true,
		}

		// Convert required vars
		for _, v := range m.Env.Required {
			em.Env.Required = append(em.Env.Required, templates.EnvVar{
				Name:         v.Name,
				Description:  v.Description,
				Instructions: v.Instructions,
				Default:      v.Default,
			})
		}

		// Convert optional vars
		for _, v := range m.Env.Optional {
			em.Env.Optional = append(em.Env.Optional, templates.EnvVar{
				Name:         v.Name,
				Description:  v.Description,
				Instructions: v.Instructions,
				Default:      v.Default,
			})
		}

		envManifests = append(envManifests, em)
	}

	content, err := templates.RenderExternal("env.example.tmpl", templates.EnvExampleData{
		Manifests: envManifests,
	})
	if err != nil {
		return fmt.Errorf("failed to render env.example: %w", err)
	}

	return os.WriteFile(outputPath, content, 0644)
}

// GenerateProcessCompose generates a process-compose.yaml file.
// Uses the unified generator from internal/processcompose package.
func (g *Generator) GenerateProcessCompose(outputPath string) error {
	config := processcompose.NewConfig()

	for _, m := range g.manifests {
		if !m.HasProcesses() {
			continue
		}

		for name, p := range m.Processes {
			// Prefix process name with package name to avoid conflicts
			processName := name
			if len(g.manifests) > 1 {
				processName = fmt.Sprintf("%s-%s", m.Name, name)
			}

			// Convert manifest ProcessConfig to ProcessInput
			// Derive port env var from process name for per-machine overrides
			input := &processcompose.ProcessInput{
				Name:       name,
				Command:    p.Command,
				Disabled:   p.Disabled,
				Namespace:  p.Namespace,
				DependsOn:  p.DependsOn,
				Port:       p.Port,
				PortEnvVar: portEnvVar(name),
				HealthPath: p.HealthPath,
				HTTPS:      p.HTTPS,
			}
			if p.Readiness != nil {
				input.Readiness = &processcompose.ReadinessConfig{
					InitialDelay:     p.Readiness.InitialDelay,
					Period:           p.Readiness.Period,
					Timeout:          p.Readiness.Timeout,
					FailureThreshold: p.Readiness.FailureThreshold,
				}
			}
			// v1.87.0: Support scheduled processes (cron/interval)
			if p.Schedule != nil {
				input.Schedule = &processcompose.ScheduleConfig{
					Cron:          p.Schedule.Cron,
					Timezone:      p.Schedule.Timezone,
					Interval:      p.Schedule.Interval,
					RunOnStart:    p.Schedule.RunOnStart,
					MaxConcurrent: p.Schedule.MaxConcurrent,
				}
			}

			proc := processcompose.ProcessFromInputWithAvailability(input, "on_failure")
			config.Processes[processName] = proc
		}
	}

	// Write with header
	gen := processcompose.NewGenerator(outputPath)
	header := "# Generated by: xplat gen process\n# Regenerate with: xplat gen process\n\n"
	return gen.WriteWithHeader(config, header)
}

// GenerateTaskfile generates a Taskfile with remote includes.
func (g *Generator) GenerateTaskfile(outputPath string, repoBaseURL string) error {
	var includes []templates.TaskfileInclude
	for _, m := range g.manifests {
		if m.Taskfile == nil || m.Taskfile.Path == "" {
			continue
		}

		ns := m.Taskfile.Namespace
		if ns == "" {
			ns = m.Name
		}

		// Build URL: https://github.com/owner/repo.git//path?ref=version
		url := fmt.Sprintf("%s/%s.git//%s?ref=%s",
			repoBaseURL, m.RepoName(), m.Taskfile.Path, m.Version)

		includes = append(includes, templates.TaskfileInclude{Namespace: ns, URL: url})
	}

	// Sort for consistent output
	sort.Slice(includes, func(i, j int) bool {
		return includes[i].Namespace < includes[j].Namespace
	})

	content, err := templates.RenderExternal("taskfile.generated.yml.tmpl", templates.TaskfileGeneratedData{
		Includes: includes,
	})
	if err != nil {
		return fmt.Errorf("failed to render taskfile: %w", err)
	}

	return os.WriteFile(outputPath, content, 0644)
}

// normalizeLanguage normalizes language names for template use.
// Supported: go, rust, bun. Empty string means no language setup.
func normalizeLanguage(lang string) string {
	switch strings.ToLower(lang) {
	case "go", "golang":
		return "go"
	case "rust":
		return "rust"
	case "bun":
		return "bun"
	default:
		return ""
	}
}

// DetectLanguage auto-detects the project language from files in baseDir.
// Returns: go, rust, bun, or empty string.
func DetectLanguage(baseDir string) string {
	// Check for language marker files
	checks := []struct {
		file string
		lang string
	}{
		{"go.mod", "go"},
		{"Cargo.toml", "rust"},
		{"bun.lockb", "bun"},
		{"package.json", "bun"}, // Prefer bun over node
	}

	for _, c := range checks {
		path := baseDir + "/" + c.file
		if _, err := os.Stat(path); err == nil {
			return c.lang
		}
	}
	return ""
}

// WorkflowOptions configures CI workflow generation.
type WorkflowOptions struct {
	Language       string // go, rust, bun, or empty
	IsExternalRepo bool   // true if binary comes from external git repo

	// xplat-specific options (for xplat's own CI)
	IsXplatSelf bool   // true if generating CI for xplat itself
	BinaryName  string // binary name for releases (e.g., "xplat")
	TagPrefix   string // tag prefix for releases (e.g., "xplat-")
	TaskBuild   string // build task name (e.g., "dev:build")
	TaskTest    string // test task name (e.g., "dev:test")
	TaskLint    string // lint task name (e.g., "dev:lint")
	TaskRelease string // release task name (e.g., "release:build:all")
	SingleOS    bool   // if true, only run on ubuntu-latest
	EnablePages bool   // if true, deploy docs to GitHub Pages after CI
}

// GenerateWorkflow generates a unified GitHub Actions CI workflow.
// This creates a minimal workflow that delegates to Taskfile.
// Uses the xplat setup action for cross-platform installation.
// Runs on Linux, macOS, and Windows.
func (g *Generator) GenerateWorkflow(outputPath string, opts WorkflowOptions) error {
	content, err := templates.RenderExternal("ci.yml.tmpl", templates.CIWorkflowData{
		Language:       normalizeLanguage(opts.Language),
		XplatRepo:      "joeblew999/xplat",
		IsExternalRepo: opts.IsExternalRepo,
		IsXplatSelf:    opts.IsXplatSelf,
		BinaryName:     opts.BinaryName,
		TagPrefix:      opts.TagPrefix,
		TaskBuild:      opts.TaskBuild,
		TaskTest:       opts.TaskTest,
		TaskLint:       opts.TaskLint,
		TaskRelease:    opts.TaskRelease,
		SingleOS:       opts.SingleOS,
		EnablePages:    opts.EnablePages,
	})
	if err != nil {
		return fmt.Errorf("failed to render CI workflow: %w", err)
	}

	return os.WriteFile(outputPath, content, 0644)
}

// GenerateWorkflowDir generates the workflow in .github/workflows/ci.yml
// Auto-detects language from files if not specified in manifest.
func (g *Generator) GenerateWorkflowDir(baseDir string) error {
	return g.GenerateWorkflowDirWithOptions(baseDir, WorkflowOptions{
		Language: DetectLanguage(baseDir),
	})
}

// GenerateWorkflowDirWithLanguage generates the workflow with explicit language.
func (g *Generator) GenerateWorkflowDirWithLanguage(baseDir string, language string) error {
	return g.GenerateWorkflowDirWithOptions(baseDir, WorkflowOptions{
		Language: language,
	})
}

// GenerateWorkflowDirWithOptions generates the workflow with full options.
func (g *Generator) GenerateWorkflowDirWithOptions(baseDir string, opts WorkflowOptions) error {
	workflowDir := baseDir + "/.github/workflows"
	if err := os.MkdirAll(workflowDir, 0755); err != nil {
		return fmt.Errorf("failed to create workflow directory: %w", err)
	}
	return g.GenerateWorkflow(workflowDir+"/ci.yml", opts)
}

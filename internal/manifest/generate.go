package manifest

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"

	"github.com/joeblew999/xplat/internal/processcompose"
)


// Generator generates files from manifests.
type Generator struct {
	manifests []*Manifest
}

// NewGenerator creates a new generator with the given manifests.
func NewGenerator(manifests []*Manifest) *Generator {
	return &Generator{manifests: manifests}
}

// GenerateEnvExample generates a .env.example file.
func (g *Generator) GenerateEnvExample(outputPath string) error {
	var buf bytes.Buffer

	buf.WriteString("# Generated by: xplat docs env\n")
	buf.WriteString("# Regenerate with: xplat docs env\n")
	buf.WriteString("#\n")
	buf.WriteString("# This file documents all environment variables needed by xplat packages.\n")
	buf.WriteString("# Copy to .env and fill in your values.\n\n")

	for _, m := range g.manifests {
		if !m.HasEnv() {
			continue
		}

		buf.WriteString(fmt.Sprintf("# === %s ===\n", m.Name))
		if m.Description != "" {
			buf.WriteString(fmt.Sprintf("# %s\n", m.Description))
		}
		buf.WriteString("\n")

		// Required vars
		for _, v := range m.Env.Required {
			writeEnvVar(&buf, v, true)
		}

		// Optional vars
		for _, v := range m.Env.Optional {
			writeEnvVar(&buf, v, false)
		}

		buf.WriteString("\n")
	}

	return os.WriteFile(outputPath, buf.Bytes(), 0644)
}

func writeEnvVar(buf *bytes.Buffer, v EnvVar, required bool) {
	if v.Description != "" {
		buf.WriteString(fmt.Sprintf("# %s", v.Description))
		if required {
			buf.WriteString(" (required)")
		}
		buf.WriteString("\n")
	}

	if v.Instructions != "" {
		for _, line := range strings.Split(strings.TrimSpace(v.Instructions), "\n") {
			buf.WriteString(fmt.Sprintf("#   %s\n", line))
		}
	}

	if v.Default != "" {
		buf.WriteString(fmt.Sprintf("# %s=%s\n", v.Name, v.Default))
	} else {
		buf.WriteString(fmt.Sprintf("%s=\n", v.Name))
	}
	buf.WriteString("\n")
}

// GenerateProcessCompose generates a process-compose.yaml file.
// Uses the unified generator from internal/processcompose package.
func (g *Generator) GenerateProcessCompose(outputPath string) error {
	config := processcompose.NewConfig()

	for _, m := range g.manifests {
		if !m.HasProcesses() {
			continue
		}

		for name, p := range m.Processes {
			// Prefix process name with package name to avoid conflicts
			processName := name
			if len(g.manifests) > 1 {
				processName = fmt.Sprintf("%s-%s", m.Name, name)
			}

			// Convert manifest ProcessConfig to ProcessInput
			input := &processcompose.ProcessInput{
				Name:       name,
				Command:    p.Command,
				Disabled:   p.Disabled,
				Namespace:  p.Namespace,
				DependsOn:  p.DependsOn,
				Port:       p.Port,
				HealthPath: p.HealthPath,
				HTTPS:      p.HTTPS,
			}
			if p.Readiness != nil {
				input.Readiness = &processcompose.ReadinessConfig{
					InitialDelay:     p.Readiness.InitialDelay,
					Period:           p.Readiness.Period,
					Timeout:          p.Readiness.Timeout,
					FailureThreshold: p.Readiness.FailureThreshold,
				}
			}

			proc := processcompose.ProcessFromInputWithAvailability(input, "on_failure")
			config.Processes[processName] = proc
		}
	}

	// Write with header
	gen := processcompose.NewGenerator(outputPath)
	header := "# Generated by: xplat gen process\n# Regenerate with: xplat gen process\n\n"
	return gen.WriteWithHeader(config, header)
}

// GenerateTaskfile generates a Taskfile with remote includes.
func (g *Generator) GenerateTaskfile(outputPath string, repoBaseURL string) error {
	const taskfileTmpl = `# Generated by: xplat gen taskfile
# Regenerate with: xplat gen taskfile

version: "3"

includes:
{{- range .Includes }}
  {{ .Namespace }}:
    taskfile: {{ .URL }}
{{- end }}

tasks:
  default:
    desc: List available tasks
    cmds:
      - task --list
`

	type include struct {
		Namespace string
		URL       string
	}

	var includes []include
	for _, m := range g.manifests {
		if m.Taskfile == nil || m.Taskfile.Path == "" {
			continue
		}

		ns := m.Taskfile.Namespace
		if ns == "" {
			ns = m.Name
		}

		// Build URL: https://github.com/owner/repo.git//path?ref=version
		url := fmt.Sprintf("%s/%s.git//%s?ref=%s",
			repoBaseURL, m.RepoName(), m.Taskfile.Path, m.Version)

		includes = append(includes, include{Namespace: ns, URL: url})
	}

	// Sort for consistent output
	sort.Slice(includes, func(i, j int) bool {
		return includes[i].Namespace < includes[j].Namespace
	})

	tmpl, err := template.New("taskfile").Parse(taskfileTmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]interface{}{"Includes": includes}); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return os.WriteFile(outputPath, buf.Bytes(), 0644)
}

// languageSetupStep returns the GitHub Actions setup step for a language.
// Supported: go, rust, bun. Empty string means no language setup.
func languageSetupStep(lang string) string {
	switch strings.ToLower(lang) {
	case "go", "golang":
		return `      - uses: actions/setup-go@v5
        with:
          go-version: "stable"
`
	case "rust":
		return `      - uses: dtolnay/rust-toolchain@stable
`
	case "bun":
		return `      - uses: oven-sh/setup-bun@v2
`
	default:
		return "" // No language setup
	}
}

// DetectLanguage auto-detects the project language from files in baseDir.
// Returns: go, rust, bun, or empty string.
func DetectLanguage(baseDir string) string {
	// Check for language marker files
	checks := []struct {
		file string
		lang string
	}{
		{"go.mod", "go"},
		{"Cargo.toml", "rust"},
		{"bun.lockb", "bun"},
		{"package.json", "bun"}, // Prefer bun over node
	}

	for _, c := range checks {
		path := baseDir + "/" + c.file
		if _, err := os.Stat(path); err == nil {
			return c.lang
		}
	}
	return ""
}

// GenerateWorkflow generates a unified GitHub Actions CI workflow.
// This creates a minimal workflow that delegates to Taskfile.
// Uses the xplat setup action for cross-platform installation.
// Runs on Linux, macOS, and Windows.
// The language parameter determines which setup action to use (go, rust, bun).
func (g *Generator) GenerateWorkflow(outputPath string, language string) error {
	langStep := languageSetupStep(language)

	workflow := `# Unified CI/CD workflow for plat-* repositories
#
# Generated by: xplat manifest gen-workflow
# Regenerate with: xplat manifest gen-workflow
#
# Uses xplat setup action for cross-platform installation.
# All CI logic lives in Taskfile - same commands work locally.

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  ci:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    name: CI (${{ matrix.os }})
    steps:
      - uses: actions/checkout@v4

` + langStep + `      - uses: joeblew999/xplat/.github/actions/setup@main

      - name: Build
        run: xplat task build

      - name: Test
        run: xplat task test

      - name: Lint
        run: xplat task lint
        continue-on-error: true
`

	return os.WriteFile(outputPath, []byte(workflow), 0644)
}

// GenerateWorkflowDir generates the workflow in .github/workflows/ci.yml
// Auto-detects language from files if not specified in manifest.
func (g *Generator) GenerateWorkflowDir(baseDir string) error {
	workflowDir := baseDir + "/.github/workflows"
	if err := os.MkdirAll(workflowDir, 0755); err != nil {
		return fmt.Errorf("failed to create workflow directory: %w", err)
	}

	// Try to detect language from files
	language := DetectLanguage(baseDir)

	return g.GenerateWorkflow(workflowDir+"/ci.yml", language)
}

// GenerateWorkflowDirWithLanguage generates the workflow with explicit language.
func (g *Generator) GenerateWorkflowDirWithLanguage(baseDir string, language string) error {
	workflowDir := baseDir + "/.github/workflows"
	if err := os.MkdirAll(workflowDir, 0755); err != nil {
		return fmt.Errorf("failed to create workflow directory: %w", err)
	}
	return g.GenerateWorkflow(workflowDir+"/ci.yml", language)
}

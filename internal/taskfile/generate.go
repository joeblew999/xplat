package taskfile

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// GenerateOptions configures Taskfile generation.
type GenerateOptions struct {
	Name        string // Project name (e.g., "plat-caddy")
	Description string // Project description
	Binary      string // Binary name (e.g., "caddy")
	MainPath    string // Path to main.go (e.g., "./cmd/caddy")
	HasTests    bool   // Include test task
	HasLint     bool   // Include lint task
}

// DefaultOptions returns sensible defaults for a Go project.
func DefaultOptions(projectDir string) GenerateOptions {
	name := filepath.Base(projectDir)

	// Try to detect binary name from cmd/*/main.go
	binary := ""
	mainPath := ""
	cmdDir := filepath.Join(projectDir, "cmd")
	if entries, err := os.ReadDir(cmdDir); err == nil {
		for _, e := range entries {
			if e.IsDir() {
				mainFile := filepath.Join(cmdDir, e.Name(), "main.go")
				if _, err := os.Stat(mainFile); err == nil {
					binary = e.Name()
					mainPath = "./cmd/" + e.Name()
					break
				}
			}
		}
	}

	// Check for tests
	hasTests := false
	if matches, _ := filepath.Glob(filepath.Join(projectDir, "**/*_test.go")); len(matches) > 0 {
		hasTests = true
	}
	// Also check root level
	if matches, _ := filepath.Glob(filepath.Join(projectDir, "*_test.go")); len(matches) > 0 {
		hasTests = true
	}

	return GenerateOptions{
		Name:     name,
		Binary:   binary,
		MainPath: mainPath,
		HasTests: hasTests,
		HasLint:  true, // Always include lint
	}
}

// Generate creates a Taskfile.yml for a plat-* project.
func Generate(outputPath string, opts GenerateOptions) error {
	// Build the binary name and main path
	binary := opts.Binary
	if binary == "" {
		binary = opts.Name
	}
	mainPath := opts.MainPath
	if mainPath == "" {
		mainPath = "."
	}

	// Use simple string building to avoid Go template escaping issues
	var content strings.Builder
	content.WriteString(fmt.Sprintf(`# %s Taskfile
#
# Generated by: xplat manifest bootstrap
# Regenerate with: xplat manifest bootstrap
#
# Run 'task' to see available commands

version: "3"

vars:
  BINARY: %s
  MAIN: %s

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  build:
    desc: Build the binary
    cmds:
      - go build -o {{.BINARY}} {{.MAIN}}

  test:
    desc: Run tests
    cmds:
`, opts.Name, binary, mainPath))

	if opts.HasTests {
		content.WriteString("      - go test ./...\n")
	} else {
		content.WriteString("      - echo \"No tests yet\"\n")
	}

	content.WriteString(`
  lint:
    desc: Run linter
    cmds:
      - golangci-lint run || echo "golangci-lint not installed, skipping"

  clean:
    desc: Clean build artifacts
    cmds:
      - rm -f {{.BINARY}}

  install:
    desc: Install to GOBIN
    cmds:
      - go install {{.MAIN}}

  run:
    desc: Build and run
    deps: [build]
    cmds:
      - ./{{.BINARY}}

  mod:
    desc: Tidy go modules
    cmds:
      - go mod tidy
`)

	return os.WriteFile(outputPath, []byte(content.String()), 0644)
}

// GitignoreOptions configures gitignore generation.
type GitignoreOptions struct {
	BinaryName string   // Name of the binary to ignore at root level
	Patterns   []string // Extra patterns from manifest
}

// GenerateGitignore creates a .gitignore for Go projects.
func GenerateGitignore(outputPath string, binaryName string) error {
	return GenerateGitignoreWithOptions(outputPath, GitignoreOptions{BinaryName: binaryName})
}

// GenerateGitignoreWithOptions creates a .gitignore with custom patterns.
func GenerateGitignoreWithOptions(outputPath string, opts GitignoreOptions) error {
	var buf bytes.Buffer

	buf.WriteString("# Generated by: xplat manifest bootstrap\n")
	buf.WriteString("# Regenerate with: xplat manifest gen-gitignore\n\n")

	// Binary (root level only)
	if opts.BinaryName != "" {
		buf.WriteString("# Binary (root level only, so cmd/binary/ is not ignored)\n")
		buf.WriteString(fmt.Sprintf("/%s\n", opts.BinaryName))
		buf.WriteString("*.exe\n\n")
	}

	// Go build artifacts
	buf.WriteString("# Go build artifacts\n")
	buf.WriteString("*.test\n")
	buf.WriteString("*.out\n")
	buf.WriteString("coverage.html\n\n")

	// Task cache
	buf.WriteString("# Task cache\n")
	buf.WriteString(".task/\n\n")

	// Standard plat-* subsystem directories (cloned sources, binaries, data)
	buf.WriteString("# Standard plat-* subsystem directories\n")
	buf.WriteString("**/.src/\n")
	buf.WriteString("**/.bin/\n")
	buf.WriteString("**/.data/\n\n")

	// Environment files
	buf.WriteString("# Environment files with secrets\n")
	buf.WriteString(".env\n")
	buf.WriteString(".env.local\n\n")

	// IDE
	buf.WriteString("# IDE\n")
	buf.WriteString(".idea/\n")
	buf.WriteString(".vscode/\n")
	buf.WriteString("*.swp\n")
	buf.WriteString("*.swo\n\n")

	// OS
	buf.WriteString("# OS\n")
	buf.WriteString(".DS_Store\n")
	buf.WriteString("Thumbs.db\n")

	// Project-specific patterns from manifest
	if len(opts.Patterns) > 0 {
		buf.WriteString("\n# Project-specific patterns\n")
		for _, p := range opts.Patterns {
			buf.WriteString(p + "\n")
		}
	}

	return os.WriteFile(outputPath, buf.Bytes(), 0644)
}

// GenerateReadme creates a README.md for plat-* projects.
func GenerateReadme(outputPath string, name, description string) error {
	const readmeTmpl = `# {{.Name}}

{{.Description}}

## Quick Start

` + "```bash" + `
# Install dependencies and build
task build

# Run tests
task test

# Run the binary
task run
` + "```" + `

## Development

` + "```bash" + `
# See all available tasks
task

# Clean build artifacts
task clean

# Install to GOBIN
task install
` + "```" + `

## Configuration

Copy ` + "`.env.example`" + ` to ` + "`.env`" + ` and configure as needed.

## xplat Integration

This is a plat-* repository managed by xplat.

` + "```bash" + `
# Install via xplat
xplat manifest install .

# Bootstrap/update standard files
xplat manifest bootstrap
` + "```" + `
`

	tmpl, err := template.New("readme").Parse(readmeTmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Default description
	if description == "" {
		description = name + " - a plat-* project"
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]string{
		"Name":        name,
		"Description": description,
	}); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return os.WriteFile(outputPath, buf.Bytes(), 0644)
}
